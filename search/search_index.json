{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tomograms Welcome to the documentation for the tomograms module. This module simplifies tasks dealing with tomograms and their respective annotations.","title":"tomograms"},{"location":"#tomograms","text":"Welcome to the documentation for the tomograms module. This module simplifies tasks dealing with tomograms and their respective annotations.","title":"tomograms"},{"location":"annotation/","text":"This module provides classes to work with tomogram annotations. Annotation This class represents a tomogram annotation. Attributes: points ( list of numpy.ndarray ) \u2013 Annnotation points name ( str ) \u2013 Name of this annotation Source code in tomograms/annotation.py 15 16 17 18 19 20 21 22 23 24 class Annotation : \"\"\"This class represents a tomogram annotation. Attributes: points (list of numpy.ndarray): Annnotation points name (str): Name of this annotation \"\"\" def __init__ ( self , points : List [ np . ndarray ], name : Optional [ str ] = None ): self . points = points self . name = \"\" if name is None else name AnnotationFile Bases: Annotation This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath ( str ) \u2013 Filepath of this annotation file df ( DataFrame ) \u2013 DataFrame of this file Source code in tomograms/annotation.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 class AnnotationFile ( Annotation ): \"\"\"This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath (str): Filepath of this annotation file df (pandas.DataFrame): DataFrame of this file \"\"\" def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_mod ( filepath ) self . filepath = filepath self . df = AnnotationFile . mod_to_pd ( self . filepath ) points = AnnotationFile . mod_points ( self . filepath ) super () . __init__ ( points , name ) @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert Returns: DataFrame of the annotation file. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_mod ( filepath ) return imodmodel . read ( filepath ) @staticmethod def check_mod ( filepath : str ): \"\"\"Ensures that a filepath is of .mod type. Args: filepath (str): Filepath to check. Raises: IOError: If the file extension is not .mod. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != \".mod\" : raise IOError ( \"Annotation must be a .mod file.\" ) @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points def tomogram_shape ( self ): \"\"\"Finds the shape of the parent tomogram of this annotation. Returns: Shape of the parent tomogram. \"\"\" header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ]) # TODO def mod_shape ( mod_path ): # model = ImodModel.from_file(mod_path) pass __init__ ( filepath , name = None ) Initializes an AnnotationFile with a .mod file. Parameters: filepath ( str ) \u2013 The filepath of the annotation to load name ( str , default: None ) \u2013 The name of this annotation Raises: IOError \u2013 If the file extension is not .mod. Source code in tomograms/annotation.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_mod ( filepath ) self . filepath = filepath self . df = AnnotationFile . mod_to_pd ( self . filepath ) points = AnnotationFile . mod_points ( self . filepath ) super () . __init__ ( points , name ) check_mod ( filepath ) staticmethod Ensures that a filepath is of .mod type. Parameters: filepath ( str ) \u2013 Filepath to check. Raises: IOError \u2013 If the file extension is not .mod. Source code in tomograms/annotation.py 70 71 72 73 74 75 76 77 78 79 80 81 82 @staticmethod def check_mod ( filepath : str ): \"\"\"Ensures that a filepath is of .mod type. Args: filepath (str): Filepath to check. Raises: IOError: If the file extension is not .mod. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != \".mod\" : raise IOError ( \"Annotation must be a .mod file.\" ) mod_points ( filepath ) staticmethod Reads a .mod file and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomograms/annotation.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points mod_to_pd ( filepath ) staticmethod Converts a .mod file to a pandas DataFrame. Parameters: filepath ( str ) \u2013 File to convert Returns: DataFrame \u2013 DataFrame of the annotation file. Raises: IOError \u2013 If the file extension is not .mod. Source code in tomograms/annotation.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert Returns: DataFrame of the annotation file. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_mod ( filepath ) return imodmodel . read ( filepath ) tomogram_shape () Finds the shape of the parent tomogram of this annotation. Returns: \u2013 Shape of the parent tomogram. Source code in tomograms/annotation.py 105 106 107 108 109 110 111 112 def tomogram_shape ( self ): \"\"\"Finds the shape of the parent tomogram of this annotation. Returns: Shape of the parent tomogram. \"\"\" header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ])","title":"Annotation"},{"location":"annotation/#tomograms.annotation.Annotation","text":"This class represents a tomogram annotation. Attributes: points ( list of numpy.ndarray ) \u2013 Annnotation points name ( str ) \u2013 Name of this annotation Source code in tomograms/annotation.py 15 16 17 18 19 20 21 22 23 24 class Annotation : \"\"\"This class represents a tomogram annotation. Attributes: points (list of numpy.ndarray): Annnotation points name (str): Name of this annotation \"\"\" def __init__ ( self , points : List [ np . ndarray ], name : Optional [ str ] = None ): self . points = points self . name = \"\" if name is None else name","title":"Annotation"},{"location":"annotation/#tomograms.annotation.AnnotationFile","text":"Bases: Annotation This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath ( str ) \u2013 Filepath of this annotation file df ( DataFrame ) \u2013 DataFrame of this file Source code in tomograms/annotation.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 class AnnotationFile ( Annotation ): \"\"\"This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath (str): Filepath of this annotation file df (pandas.DataFrame): DataFrame of this file \"\"\" def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_mod ( filepath ) self . filepath = filepath self . df = AnnotationFile . mod_to_pd ( self . filepath ) points = AnnotationFile . mod_points ( self . filepath ) super () . __init__ ( points , name ) @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert Returns: DataFrame of the annotation file. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_mod ( filepath ) return imodmodel . read ( filepath ) @staticmethod def check_mod ( filepath : str ): \"\"\"Ensures that a filepath is of .mod type. Args: filepath (str): Filepath to check. Raises: IOError: If the file extension is not .mod. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != \".mod\" : raise IOError ( \"Annotation must be a .mod file.\" ) @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points def tomogram_shape ( self ): \"\"\"Finds the shape of the parent tomogram of this annotation. Returns: Shape of the parent tomogram. \"\"\" header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ]) # TODO def mod_shape ( mod_path ): # model = ImodModel.from_file(mod_path) pass","title":"AnnotationFile"},{"location":"annotation/#tomograms.annotation.AnnotationFile.__init__","text":"Initializes an AnnotationFile with a .mod file. Parameters: filepath ( str ) \u2013 The filepath of the annotation to load name ( str , default: None ) \u2013 The name of this annotation Raises: IOError \u2013 If the file extension is not .mod. Source code in tomograms/annotation.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_mod ( filepath ) self . filepath = filepath self . df = AnnotationFile . mod_to_pd ( self . filepath ) points = AnnotationFile . mod_points ( self . filepath ) super () . __init__ ( points , name )","title":"__init__"},{"location":"annotation/#tomograms.annotation.AnnotationFile.check_mod","text":"Ensures that a filepath is of .mod type. Parameters: filepath ( str ) \u2013 Filepath to check. Raises: IOError \u2013 If the file extension is not .mod. Source code in tomograms/annotation.py 70 71 72 73 74 75 76 77 78 79 80 81 82 @staticmethod def check_mod ( filepath : str ): \"\"\"Ensures that a filepath is of .mod type. Args: filepath (str): Filepath to check. Raises: IOError: If the file extension is not .mod. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != \".mod\" : raise IOError ( \"Annotation must be a .mod file.\" )","title":"check_mod"},{"location":"annotation/#tomograms.annotation.AnnotationFile.mod_points","text":"Reads a .mod file and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomograms/annotation.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points","title":"mod_points"},{"location":"annotation/#tomograms.annotation.AnnotationFile.mod_to_pd","text":"Converts a .mod file to a pandas DataFrame. Parameters: filepath ( str ) \u2013 File to convert Returns: DataFrame \u2013 DataFrame of the annotation file. Raises: IOError \u2013 If the file extension is not .mod. Source code in tomograms/annotation.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert Returns: DataFrame of the annotation file. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_mod ( filepath ) return imodmodel . read ( filepath )","title":"mod_to_pd"},{"location":"annotation/#tomograms.annotation.AnnotationFile.tomogram_shape","text":"Finds the shape of the parent tomogram of this annotation. Returns: \u2013 Shape of the parent tomogram. Source code in tomograms/annotation.py 105 106 107 108 109 110 111 112 def tomogram_shape ( self ): \"\"\"Finds the shape of the parent tomogram of this annotation. Returns: Shape of the parent tomogram. \"\"\" header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ])","title":"tomogram_shape"},{"location":"subtomogram/","text":"Subtomogram Bases: Tomogram A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram ( Tomogram ) \u2013 The tomogram from which this subtomogram was lower_bounds ( ndarray ) \u2013 The lower bounds of the subtomogram as they data ( ndarray ) \u2013 The 3D data of the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomograms/subtomogram.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Subtomogram ( Tomogram ): \"\"\" A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram (Tomogram): The tomogram from which this subtomogram was created. lower_bounds (np.ndarray): The lower bounds of the subtomogram as they would be indexed in the parent tomogram. data (np.ndarray): The 3D data of the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations ) __init__ ( parent_tomogram , lower_bounds , shape ) Initializes a Subtomogram instance. Parameters: parent_tomogram ( Tomogram ) \u2013 The parent tomogram. lower_bounds ( ndarray ) \u2013 The lower bounds for the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomograms/subtomogram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations ) SubtomogramGenerator A class for generating subtomograms from a parent tomogram. Attributes: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. annotations ( List [ Annotation ] ) \u2013 The annotations from the parent vol_shape ( Tuple [ int , int , int ] ) \u2013 The shape of the volumes to be pads ( Tuple [ int , int , int ] ) \u2013 The padding to apply to the boundaries. gen ( Generator ) \u2013 Random number generator for sampling. Source code in tomograms/subtomogram.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class SubtomogramGenerator : \"\"\" A class for generating subtomograms from a parent tomogram. Attributes: tomogram (Tomogram): The parent tomogram to sample from. annotations (List[Annotation]): The annotations from the parent tomogram. vol_shape (Tuple[int, int, int]): The shape of the volumes to be generated. pads (Tuple[int, int, int]): The padding to apply to the boundaries. gen (np.random.Generator): Random number generator for sampling. \"\"\" def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng () def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" ) def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points __init__ ( tomogram ) Initializes a SubtomogramGenerator instance. Parameters: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. Source code in tomograms/subtomogram.py 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng () find_annotation_points () Returns a list of points that are present in the annotations. Returns: List [ ndarray ] \u2013 A list of annotation points. Source code in tomograms/subtomogram.py 202 203 204 205 206 207 208 209 210 211 212 def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points negative_sample () Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: Subtomogram \u2013 The newly created subtomogram. Raises: Exception \u2013 If unable to find a valid subtomogram without annotation Source code in tomograms/subtomogram.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" ) positive_sample ( point = None ) Returns a random subtomogram containing the specified point. The point will not be closer than pads voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Parameters: point ( Optional [ ndarray ] , default: None ) \u2013 The point to include in the Returns: Subtomogram \u2013 The newly created subtomogram. Source code in tomograms/subtomogram.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) set_vol_shape ( new_vol_shape ) Sets a new volume shape for the generator. Parameters: new_vol_shape ( tuple [ int , int , int ] ) \u2013 The new volume shape. Source code in tomograms/subtomogram.py 118 119 120 121 122 123 124 125 def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape in_bounds ( shape , point ) Checks if the point is within the bounds of an array with the given shape . Parameters: shape ( ndarray ) \u2013 The shape of the array. point (np.ndarray): The Returns: bool \u2013 True if the point is within bounds, False otherwise. Source code in tomograms/subtomogram.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def in_bounds ( shape : np . ndarray , point : np . ndarray ) -> bool : \"\"\" Checks if the `point` is within the bounds of an array with the given `shape`. Args: shape (np.ndarray): The shape of the array. point (np.ndarray): The point to check. Returns: True if the point is within bounds, False otherwise. \"\"\" for ( s , p ) in zip ( shape , point ): if p < 0 or p >= s : return False return True","title":"Subtomogram"},{"location":"subtomogram/#tomograms.subtomogram.Subtomogram","text":"Bases: Tomogram A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram ( Tomogram ) \u2013 The tomogram from which this subtomogram was lower_bounds ( ndarray ) \u2013 The lower bounds of the subtomogram as they data ( ndarray ) \u2013 The 3D data of the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomograms/subtomogram.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Subtomogram ( Tomogram ): \"\"\" A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram (Tomogram): The tomogram from which this subtomogram was created. lower_bounds (np.ndarray): The lower bounds of the subtomogram as they would be indexed in the parent tomogram. data (np.ndarray): The 3D data of the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations )","title":"Subtomogram"},{"location":"subtomogram/#tomograms.subtomogram.Subtomogram.__init__","text":"Initializes a Subtomogram instance. Parameters: parent_tomogram ( Tomogram ) \u2013 The parent tomogram. lower_bounds ( ndarray ) \u2013 The lower bounds for the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomograms/subtomogram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations )","title":"__init__"},{"location":"subtomogram/#tomograms.subtomogram.SubtomogramGenerator","text":"A class for generating subtomograms from a parent tomogram. Attributes: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. annotations ( List [ Annotation ] ) \u2013 The annotations from the parent vol_shape ( Tuple [ int , int , int ] ) \u2013 The shape of the volumes to be pads ( Tuple [ int , int , int ] ) \u2013 The padding to apply to the boundaries. gen ( Generator ) \u2013 Random number generator for sampling. Source code in tomograms/subtomogram.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class SubtomogramGenerator : \"\"\" A class for generating subtomograms from a parent tomogram. Attributes: tomogram (Tomogram): The parent tomogram to sample from. annotations (List[Annotation]): The annotations from the parent tomogram. vol_shape (Tuple[int, int, int]): The shape of the volumes to be generated. pads (Tuple[int, int, int]): The padding to apply to the boundaries. gen (np.random.Generator): Random number generator for sampling. \"\"\" def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng () def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" ) def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points","title":"SubtomogramGenerator"},{"location":"subtomogram/#tomograms.subtomogram.SubtomogramGenerator.__init__","text":"Initializes a SubtomogramGenerator instance. Parameters: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. Source code in tomograms/subtomogram.py 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng ()","title":"__init__"},{"location":"subtomogram/#tomograms.subtomogram.SubtomogramGenerator.find_annotation_points","text":"Returns a list of points that are present in the annotations. Returns: List [ ndarray ] \u2013 A list of annotation points. Source code in tomograms/subtomogram.py 202 203 204 205 206 207 208 209 210 211 212 def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points","title":"find_annotation_points"},{"location":"subtomogram/#tomograms.subtomogram.SubtomogramGenerator.negative_sample","text":"Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: Subtomogram \u2013 The newly created subtomogram. Raises: Exception \u2013 If unable to find a valid subtomogram without annotation Source code in tomograms/subtomogram.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" )","title":"negative_sample"},{"location":"subtomogram/#tomograms.subtomogram.SubtomogramGenerator.positive_sample","text":"Returns a random subtomogram containing the specified point. The point will not be closer than pads voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Parameters: point ( Optional [ ndarray ] , default: None ) \u2013 The point to include in the Returns: Subtomogram \u2013 The newly created subtomogram. Source code in tomograms/subtomogram.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape )","title":"positive_sample"},{"location":"subtomogram/#tomograms.subtomogram.SubtomogramGenerator.set_vol_shape","text":"Sets a new volume shape for the generator. Parameters: new_vol_shape ( tuple [ int , int , int ] ) \u2013 The new volume shape. Source code in tomograms/subtomogram.py 118 119 120 121 122 123 124 125 def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape","title":"set_vol_shape"},{"location":"subtomogram/#tomograms.subtomogram.in_bounds","text":"Checks if the point is within the bounds of an array with the given shape . Parameters: shape ( ndarray ) \u2013 The shape of the array. point (np.ndarray): The Returns: bool \u2013 True if the point is within bounds, False otherwise. Source code in tomograms/subtomogram.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def in_bounds ( shape : np . ndarray , point : np . ndarray ) -> bool : \"\"\" Checks if the `point` is within the bounds of an array with the given `shape`. Args: shape (np.ndarray): The shape of the array. point (np.ndarray): The point to check. Returns: True if the point is within bounds, False otherwise. \"\"\" for ( s , p ) in zip ( shape , point ): if p < 0 or p >= s : return False return True","title":"in_bounds"},{"location":"supercomputer_utils/","text":"A collection of utilities for use on BYU's supercomputer. all_fm_tomograms () Collect all pairs of .rec tomogram filepaths and flagellar motor .mod filepaths. Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their annotations. Source code in tomograms/supercomputer_utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def all_fm_tomograms () -> List [ TomogramFile ]: \"\"\"Collect all pairs of `.rec` tomogram filepaths and flagellar motor `.mod` filepaths. Returns: TomogramFile objects with their annotations. \"\"\" tomograms = [] # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms return tomograms seek_annotated_tomos ( directories , tomo_regex , annotation_regexes , annotation_names ) Collect pairs of tomogram files and their corresponding annotation files. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns to annotation_names ( list of str ) \u2013 A list of names for the annotations. Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their corresponding List [ TomogramFile ] \u2013 annotations. Source code in tomograms/supercomputer_utils.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def seek_annotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], annotation_names : List [ str ] ) -> List [ TomogramFile ]: \"\"\"Collect pairs of tomogram files and their corresponding annotation files. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns to match annotation filenames. annotation_names (list of str): A list of names for the annotations. Returns: TomogramFile objects with their corresponding annotations. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : tomogram_file = matches [ 0 ] annotation_files = matches [ 1 :] annotations = [] for ( file , name ) in zip ( annotation_files , annotation_names ): annotations . append ( AnnotationFile ( file , name )) tomo = TomogramFile ( tomogram_file , annotations , load = False ) tomos . append ( tomo ) return tomos seek_dirs ( root , regex , directories = None ) Search for directories matching the given regex recursively within the specified root directory. Parameters: root ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the directory names. directories ( list , default: None ) \u2013 A list to accumulate matched directories. Returns: Union [ List [ str ], None] \u2013 A list of paths of matching directories. Source code in tomograms/supercomputer_utils.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def seek_dirs ( root : str , regex : re . Pattern , directories : Optional [ List [ str ]] = None ) -> Union [ List [ str ], None ]: \"\"\"Search for directories matching the given regex recursively within the specified root directory. Args: root (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the directory names. directories (list, optional): A list to accumulate matched directories. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of paths of matching directories. \"\"\" if directories is None : directories = [] for root , dirs , _ in os . walk ( root ): for dir in dirs : if regex . match ( dir ): directories . append ( os . path . join ( root , dir )) else : directories = seek_dirs ( dir , regex , directories ) return directories seek_file ( directory , regex ) Search for a file matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex (re.Pattern) \u2013 The regex pattern to match the filenames. Returns: Union [ str , None] \u2013 The full path of the matching file, or None if no match is Union [ str , None] \u2013 found. Source code in tomograms/supercomputer_utils.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def seek_file ( directory : str , regex : List [ re . Pattern ]) -> Union [ str , None ]: \"\"\"Search for a file matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the filenames. Returns: The full path of the matching file, or None if no match is found. \"\"\" for root , dirs , files in os . walk ( directory ): for file in files : if regex . match ( file ): return os . path . join ( root , file ) for dir in dirs : target = seek_file ( dir , regex ) if target is not None : return target return None seek_set ( directory , regexes , matches = None ) Recursively search the specified directory for exactly one match for each regex in the list. Parameters: directory ( str ) \u2013 The directory to search. regexes ( list of re.Pattern ) \u2013 A list of regex patterns to match filenames. matches ( list , default: None ) \u2013 A list to accumulate matches. Should not be Returns: Union [ List [ str ], None] \u2013 A list of matching file paths or None if extra matches are found. Source code in tomograms/supercomputer_utils.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def seek_set ( directory : str , regexes : List [ re . Pattern ], matches : List [ str ] = None ) -> Union [ List [ str ], None ]: \"\"\"Recursively search the specified directory for exactly one match for each regex in the list. Args: directory (str): The directory to search. regexes (list of re.Pattern): A list of regex patterns to match filenames. matches (list, optional): A list to accumulate matches. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of matching file paths or None if extra matches are found. \"\"\" if matches is None : matches = [ None for _ in regexes ] for root , dirs , files in os . walk ( directory ): for file in files : for r_idx , r in enumerate ( regexes ): if re . match ( r , file ): if matches [ r_idx ] is None : matches [ r_idx ] = os . path . join ( root , file ) else : return None # Extra match found return matches","title":"Supercomputer utils"},{"location":"supercomputer_utils/#tomograms.supercomputer_utils.all_fm_tomograms","text":"Collect all pairs of .rec tomogram filepaths and flagellar motor .mod filepaths. Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their annotations. Source code in tomograms/supercomputer_utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def all_fm_tomograms () -> List [ TomogramFile ]: \"\"\"Collect all pairs of `.rec` tomogram filepaths and flagellar motor `.mod` filepaths. Returns: TomogramFile objects with their annotations. \"\"\" tomograms = [] # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms return tomograms","title":"all_fm_tomograms"},{"location":"supercomputer_utils/#tomograms.supercomputer_utils.seek_annotated_tomos","text":"Collect pairs of tomogram files and their corresponding annotation files. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns to annotation_names ( list of str ) \u2013 A list of names for the annotations. Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their corresponding List [ TomogramFile ] \u2013 annotations. Source code in tomograms/supercomputer_utils.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def seek_annotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], annotation_names : List [ str ] ) -> List [ TomogramFile ]: \"\"\"Collect pairs of tomogram files and their corresponding annotation files. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns to match annotation filenames. annotation_names (list of str): A list of names for the annotations. Returns: TomogramFile objects with their corresponding annotations. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : tomogram_file = matches [ 0 ] annotation_files = matches [ 1 :] annotations = [] for ( file , name ) in zip ( annotation_files , annotation_names ): annotations . append ( AnnotationFile ( file , name )) tomo = TomogramFile ( tomogram_file , annotations , load = False ) tomos . append ( tomo ) return tomos","title":"seek_annotated_tomos"},{"location":"supercomputer_utils/#tomograms.supercomputer_utils.seek_dirs","text":"Search for directories matching the given regex recursively within the specified root directory. Parameters: root ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the directory names. directories ( list , default: None ) \u2013 A list to accumulate matched directories. Returns: Union [ List [ str ], None] \u2013 A list of paths of matching directories. Source code in tomograms/supercomputer_utils.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def seek_dirs ( root : str , regex : re . Pattern , directories : Optional [ List [ str ]] = None ) -> Union [ List [ str ], None ]: \"\"\"Search for directories matching the given regex recursively within the specified root directory. Args: root (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the directory names. directories (list, optional): A list to accumulate matched directories. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of paths of matching directories. \"\"\" if directories is None : directories = [] for root , dirs , _ in os . walk ( root ): for dir in dirs : if regex . match ( dir ): directories . append ( os . path . join ( root , dir )) else : directories = seek_dirs ( dir , regex , directories ) return directories","title":"seek_dirs"},{"location":"supercomputer_utils/#tomograms.supercomputer_utils.seek_file","text":"Search for a file matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex (re.Pattern) \u2013 The regex pattern to match the filenames. Returns: Union [ str , None] \u2013 The full path of the matching file, or None if no match is Union [ str , None] \u2013 found. Source code in tomograms/supercomputer_utils.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def seek_file ( directory : str , regex : List [ re . Pattern ]) -> Union [ str , None ]: \"\"\"Search for a file matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the filenames. Returns: The full path of the matching file, or None if no match is found. \"\"\" for root , dirs , files in os . walk ( directory ): for file in files : if regex . match ( file ): return os . path . join ( root , file ) for dir in dirs : target = seek_file ( dir , regex ) if target is not None : return target return None","title":"seek_file"},{"location":"supercomputer_utils/#tomograms.supercomputer_utils.seek_set","text":"Recursively search the specified directory for exactly one match for each regex in the list. Parameters: directory ( str ) \u2013 The directory to search. regexes ( list of re.Pattern ) \u2013 A list of regex patterns to match filenames. matches ( list , default: None ) \u2013 A list to accumulate matches. Should not be Returns: Union [ List [ str ], None] \u2013 A list of matching file paths or None if extra matches are found. Source code in tomograms/supercomputer_utils.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def seek_set ( directory : str , regexes : List [ re . Pattern ], matches : List [ str ] = None ) -> Union [ List [ str ], None ]: \"\"\"Recursively search the specified directory for exactly one match for each regex in the list. Args: directory (str): The directory to search. regexes (list of re.Pattern): A list of regex patterns to match filenames. matches (list, optional): A list to accumulate matches. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of matching file paths or None if extra matches are found. \"\"\" if matches is None : matches = [ None for _ in regexes ] for root , dirs , files in os . walk ( directory ): for file in files : for r_idx , r in enumerate ( regexes ): if re . match ( r , file ): if matches [ r_idx ] is None : matches [ r_idx ] = os . path . join ( root , file ) else : return None # Extra match found return matches","title":"seek_set"},{"location":"tomogram/","text":"Tomogram Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations ( list of Annotation ) \u2013 Annotations corresponding to this tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. shape ( ndarray ) \u2013 A 3-element array representing the shape of the tomogram data. Source code in tomograms/tomogram.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Tomogram : \"\"\"Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations (list of Annotation): Annotations corresponding to this tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. shape (numpy.ndarray): A 3-element array representing the shape of the tomogram data. \"\"\" def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation ) def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points __init__ ( data , annotations = None ) Initialize a Tomogram instance. Parameters: data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. annotations ( list of Annotation , default: None ) \u2013 A list of annotations corresponding to the tomogram. Defaults to None. Source code in tomograms/tomogram.py 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape add_annotation ( annotation ) Add an annotation to the tomogram. Parameters: annotation ( Annotation ) \u2013 An annotation object to be added to the tomogram's annotations. Source code in tomograms/tomogram.py 41 42 43 44 45 46 47 48 def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation ) annotation_points ( annotation_index = None ) Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Parameters: annotation_index ( int , default: None ) \u2013 The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: \u2013 A list of points from the specified annotation or all annotations. Source code in tomograms/tomogram.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points TomogramFile Bases: Tomogram Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Attributes: filepath ( str ) \u2013 The file path to the tomogram file. annotations (list of Annotation) ( str ) \u2013 Annotations corresponding to the tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. Source code in tomograms/tomogram.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 class TomogramFile ( Tomogram ): \"\"\"Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Attributes: filepath (str): The file path to the tomogram file. annotations (list of Annotation): Annotations corresponding to the tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. \"\"\" def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = False ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to False. \"\"\" if load : self . data = self . load () else : self . data = None self . annotations = annotations self . filepath = filepath def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_ @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . data , ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . data , in_range = ( p2 , p98 )) self . data = data_rescale return self . data def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . data def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ): shape = annotation . tomogram_shape () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape __init__ ( filepath , annotations = None , * , load = False ) Initialize a TomogramFile instance. Parameters: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation , default: None ) \u2013 Annotations corresponding to the tomogram. Defaults to None. load ( bool , default: False ) \u2013 Whether to load tomogram array data immediately. Defaults to False. Source code in tomograms/tomogram.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = False ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to False. \"\"\" if load : self . data = self . load () else : self . data = None self . annotations = annotations self . filepath = filepath get_shape_from_annotations () Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles are in self.annotations, raises an exception. Returns: ndarray \u2013 The shape of the tomogram as inferred from ndarray \u2013 self.annotations. Raises: Exception \u2013 If no AnnotationFile objects are in self.annotations. Exception \u2013 If there are multiple AnnotationFile objects in Source code in tomograms/tomogram.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ): shape = annotation . tomogram_shape () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape load ( * , preprocess = True ) Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: \u2013 The loaded tomogram data. Raises: IOError \u2013 If the file type is not supported. Source code in tomograms/tomogram.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data mrc_to_np ( filepath ) staticmethod Convert a .mrc or .rec file to a numpy array. Parameters: filepath ( str ) \u2013 The file path to the .mrc or .rec file. Returns: ndarray \u2013 The data loaded as a numpy array. Source code in tomograms/tomogram.py 166 167 168 169 170 171 172 173 174 175 176 177 178 @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data process () Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: ndarray \u2013 The processed tomogram data. Source code in tomograms/tomogram.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . data , ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . data , in_range = ( p2 , p98 )) self . data = data_rescale return self . data reload () Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. Returns: ndarray \u2013 The reloaded tomogram data. Source code in tomograms/tomogram.py 195 196 197 198 199 200 201 202 203 204 205 def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . data rescale ( array ) staticmethod Rescale array values to the range [0, 1]. Parameters: array ( ndarray ) \u2013 The array to be rescaled. Returns: ndarray \u2013 The rescaled array. Source code in tomograms/tomogram.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_","title":"Tomogram"},{"location":"tomogram/#tomograms.tomogram.Tomogram","text":"Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations ( list of Annotation ) \u2013 Annotations corresponding to this tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. shape ( ndarray ) \u2013 A 3-element array representing the shape of the tomogram data. Source code in tomograms/tomogram.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Tomogram : \"\"\"Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations (list of Annotation): Annotations corresponding to this tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. shape (numpy.ndarray): A 3-element array representing the shape of the tomogram data. \"\"\" def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation ) def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points","title":"Tomogram"},{"location":"tomogram/#tomograms.tomogram.Tomogram.__init__","text":"Initialize a Tomogram instance. Parameters: data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. annotations ( list of Annotation , default: None ) \u2013 A list of annotations corresponding to the tomogram. Defaults to None. Source code in tomograms/tomogram.py 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape","title":"__init__"},{"location":"tomogram/#tomograms.tomogram.Tomogram.add_annotation","text":"Add an annotation to the tomogram. Parameters: annotation ( Annotation ) \u2013 An annotation object to be added to the tomogram's annotations. Source code in tomograms/tomogram.py 41 42 43 44 45 46 47 48 def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation )","title":"add_annotation"},{"location":"tomogram/#tomograms.tomogram.Tomogram.annotation_points","text":"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Parameters: annotation_index ( int , default: None ) \u2013 The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: \u2013 A list of points from the specified annotation or all annotations. Source code in tomograms/tomogram.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points","title":"annotation_points"},{"location":"tomogram/#tomograms.tomogram.TomogramFile","text":"Bases: Tomogram Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Attributes: filepath ( str ) \u2013 The file path to the tomogram file. annotations (list of Annotation) ( str ) \u2013 Annotations corresponding to the tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. Source code in tomograms/tomogram.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 class TomogramFile ( Tomogram ): \"\"\"Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Attributes: filepath (str): The file path to the tomogram file. annotations (list of Annotation): Annotations corresponding to the tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. \"\"\" def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = False ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to False. \"\"\" if load : self . data = self . load () else : self . data = None self . annotations = annotations self . filepath = filepath def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_ @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . data , ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . data , in_range = ( p2 , p98 )) self . data = data_rescale return self . data def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . data def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ): shape = annotation . tomogram_shape () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape","title":"TomogramFile"},{"location":"tomogram/#tomograms.tomogram.TomogramFile.__init__","text":"Initialize a TomogramFile instance. Parameters: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation , default: None ) \u2013 Annotations corresponding to the tomogram. Defaults to None. load ( bool , default: False ) \u2013 Whether to load tomogram array data immediately. Defaults to False. Source code in tomograms/tomogram.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = False ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to False. \"\"\" if load : self . data = self . load () else : self . data = None self . annotations = annotations self . filepath = filepath","title":"__init__"},{"location":"tomogram/#tomograms.tomogram.TomogramFile.get_shape_from_annotations","text":"Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles are in self.annotations, raises an exception. Returns: ndarray \u2013 The shape of the tomogram as inferred from ndarray \u2013 self.annotations. Raises: Exception \u2013 If no AnnotationFile objects are in self.annotations. Exception \u2013 If there are multiple AnnotationFile objects in Source code in tomograms/tomogram.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ): shape = annotation . tomogram_shape () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape","title":"get_shape_from_annotations"},{"location":"tomogram/#tomograms.tomogram.TomogramFile.load","text":"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: \u2013 The loaded tomogram data. Raises: IOError \u2013 If the file type is not supported. Source code in tomograms/tomogram.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data","title":"load"},{"location":"tomogram/#tomograms.tomogram.TomogramFile.mrc_to_np","text":"Convert a .mrc or .rec file to a numpy array. Parameters: filepath ( str ) \u2013 The file path to the .mrc or .rec file. Returns: ndarray \u2013 The data loaded as a numpy array. Source code in tomograms/tomogram.py 166 167 168 169 170 171 172 173 174 175 176 177 178 @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data","title":"mrc_to_np"},{"location":"tomogram/#tomograms.tomogram.TomogramFile.process","text":"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: ndarray \u2013 The processed tomogram data. Source code in tomograms/tomogram.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . data , ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . data , in_range = ( p2 , p98 )) self . data = data_rescale return self . data","title":"process"},{"location":"tomogram/#tomograms.tomogram.TomogramFile.reload","text":"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. Returns: ndarray \u2013 The reloaded tomogram data. Source code in tomograms/tomogram.py 195 196 197 198 199 200 201 202 203 204 205 def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . data","title":"reload"},{"location":"tomogram/#tomograms.tomogram.TomogramFile.rescale","text":"Rescale array values to the range [0, 1]. Parameters: array ( ndarray ) \u2013 The array to be rescaled. Returns: ndarray \u2013 The rescaled array. Source code in tomograms/tomogram.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_","title":"rescale"}]}